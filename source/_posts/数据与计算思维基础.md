---
title: 数据与计算思维基础
toc: true
categories:
  - CS
tags: [笔记]
date: 2024-10-01 12:23:00
updated: 2024-10-02 19:50:00
---

本文是《程序设计基础》课程的开篇部分。

## 导论

~~这课程没点计算机基础还真比数学都难学。~~

<!-- more -->

至于什么是“数据”与“计算思维”，在此本人给出通俗的解释。

**数据，是传达信息的集合。** 例如数值、文字、图像、音频等都是数据，能给我们传递具体的信息。

> In common usage, **data is a collection of discrete or continuous values that convey information**, describing the quantity, quality, fact, statistics, other basic units of meaning, or simply sequences of symbols that may be further interpreted formally.

**计算思维，是指通过计算机可以做到的方式，来分析、表达和求解问题，并设计自动化的解决方案的思维能力。** 计算机不是人，计算机必须依据精确完美的程序才能执行任务。简单地说，计算思维能让我们知道怎么写程序能让计算机解决问题。

> Computational thinking (CT) refers to **the thought processes involved in formulating problems so their solutions can be represented as computational steps and algorithms**. In education, CT is a set of problem-solving methods that involve expressing problems and their solutions in ways that a computer could also execute. It involves automation of processes, but also using computing to explore, analyze, and understand processes (natural and artificial).

## 计算机史

~~为了应付考试需要，在此插入一些历史知识，阅读和了解一下就行了。~~

### 计算工具发展史

1. **手动式计算工具：**

    - 古代中国具有代表性的手动式计算工具是**算盘**。算盘提供了计算过程中存储数值的手段和一套计算规则（口诀）。

2. **机械式计算工具：**

    - *[法]帕斯卡（Pascal）* 利用齿轮传动，发明了第一台机械计算机：帕斯卡加法器，即**帕斯卡机**。首次确立了计算机器和自动计算的概念。

    - *[德]莱布尼茨（Leibniz）* 发明了能够进行十进制四则运算的机器，后来提出了**二进制的概念**以及“可以用机械代替人进行繁琐重复的计算工作”的思想。

    - *[法]杰卡德（Jacquard）* 利用**穿孔纸带**，解决了数据输入的手段问题。

    - *[英]巴贝奇（Babbage）* 设计了差分机和分析机，编制了**第一个计算机程序**。

    - *[英]布尔（Boole）* 创立了布尔代数，奠定了**开关电路**设计的理论基础。

3. **机电式计算机：**

    - *[德]朱斯（Zuse）* 发明了第一台**二进制计算机** *Z-1*，实现了浮点计数法、二进制运算和带存储地址的指令等设计思想。

    - *[德]艾肯（Aiken）* 发明了**自动顺序控制计算机** *MARK-1*。

4. **电子计算机：**

    - **1946年**，美国的宾夕法尼亚大学研制了第一台**电子数字积分式计算机** *ENIAC*，采用电子器件（电子真空管、继电器和其他元件）替代了机械齿轮或电动机械。这台计算机计算速度快，但是编辑程序难。

### 电子计算机发展史

#### 电子计算机的四个时期

|代数|一|二|三|四|
|---|---|---|---|---|
|年份|1946|1958|1965|1971|
|**特征**|**电子管**|**晶体管**|**中小规模集成电路**|**（超）大规模集成电路**|
|内存|延迟线/磁芯|磁芯|半导体|半导体|
|外存|纸带/磁带|磁带/磁盘|磁带/磁盘|磁盘/光盘|
|软件|机器语言/汇编语言|高级语言|高级语言/操作系统|操作系统/应用软件|
|国际代表|ENIAC|IBM 7000|IBM System，360|/|
|中国代表|103机，119机（109甲机）|109乙机，109丙机（功勋计算机）|757机，银河-I|长城微机，银河，曙光，神威，天河，星云|

#### 电子计算机的发展趋势

电子计算机在应用方面，从科学计算，到事务管理与工业控制，再发展到计算机网络。

电子计算机在性能方面，逐渐向体积小、速度快、寿命长、能耗少的方向发展。

**摩尔定律**，指芯片集成晶体管的能力**每18个月**增长一倍，其计算能力也增长一倍。摩尔定律在2013年失效了，失效的主要原因是元件的高温和漏电问题。


#### 其他

~~重视校史和家国情怀的学校自然少不了塞点私货。~~

1. *高庆狮* 院士是119机（109甲机），109乙机，109丙机（功勋计算机）和757机的体系结构设计者（之一）。

2. 超级计算机是功能最强、运算速度最快、存储容量最大的一类计算机，多用于国家高科技领域和尖端技术研究，是国家科技发展水平和综合国力的重要标志。

    - 中国的天河系列和“神威·太湖之光”超级计算机的计算速度数量级是千万亿次，衡量单位是PFLOPS。

    - “神威·太湖之光”获得“戈登·贝尔”奖，采用中国自主研发的“申威26010”众核处理器和64位申威指令系统，持续性能为93PFLOPS。

### 计算机应用领域

传统的计算机应用领域包括：科学计算（数值计算），信息处理，过程控制，计算机辅助系统，计算机网络。

现代（21世纪早期）的计算机应用领域包括：人工智能，物联网，云计算，大数据，多媒体应用。

#### 人工智能

~~专门展开介绍人工智能是因为我是人工智能专业的。~~

**人工智能（Artificial Intelligence, AI）** 的目标是用计算机模拟人的意识和思维。 *[英]图灵（Turing）* 是**人工智能之父、计算机科学之父**。

人工智能的“智能”包括：计算智能（IBM 深蓝、Alpha Go、搜索引擎），感知智能（语音识别、图像处理），认知智能（推理、理解、思考），具身智能（与环境的实时交互）。

人工智能的应用领域包括：计算机视觉（Computer Vision, CV），自然语言处理（Natural Language Processing, NLP），语音识别，机器人，搜索引擎，数据挖掘与知识发现，知识图谱等。

**机器学习（Machine Learning, ML）** 是实现人工智能的一种方法，**深度学习（Deep Learning, DL）** 是实现机器学习的一种方法。因此有关系：

$ DL \in ML \in AI $

#### 大数据

大数据的特点是4个V：
1. Volume：数据量巨大。
2. Velocity：数据产生和传播的速度极快。
3. Variety：数据的模态多样。
4. Veracity：数据的真伪难辨。

大数据的技术基础是存储能力、计算能力和网络带宽的增加。

大数据的两大核心技术是分布式存储和分布式处理。

## 离散数据的表示

所谓**离散数据（discrete data）**，是相对于连续数据（continuous data）而言的。通俗地说，离散数据就比如一个数字或一些文字，数据内包含的具体细节（数字或文字的个数）是可被计数的。连续数据就比如图像——在现实世界中，谁能说清人眼看到的一个画面是由多少像素点组成的呢？

我们先来了解一下离散数据在计算机中是如何被表示的。

### 二进制

首先需要了解一个事实，计算机内存储数据的方式是采用**二进制（binary）**。之所以采用二进制，是因为物理上实现起来简单——利用电路的开合就可以实现了。

#### 零和一

类比十进制（decimal）的“逢10进1”，二进制的规则是“逢2进1”，二进制中唯一出现的数字是 `0` 和 `1`。举例：

`0D=0B` `1D=1B` `2D=10B` `3D=11B` `4D=100B`

`0` 也可理解为假（否）和断开（低电平、无信号）。`1` 也可理解为真（是）和连通（高电平、有信号）。

#### 位和字节

存储**1位二进制数**所需的空间称为**位（bit, b）**，也叫比特。存储**8位二进制数**所需的空间为**字节（Byte, B）**。有换算关系：

$ 1B(Byte)=8b(bit) $

位是最小的存储单位，字节是最小的可寻址单位。

更大的存储单位之间是以 $ 2^{10}=1024 $（而非 $ 1000 $）为一个级别来换算的。有换算关系：

$ 1KB=1024B \\ $
$ 1MB=1024KB \\ $
$ 1GB=1024MB \\ $

除此之外，依次还有 TB，PB，EB，ZB 等单位。

#### 进制转换

十进制到二进制的换算，整数部分可采用**除二取余法**（短除法的一种）：用整数部分不断除以2，并记下每次的余数，直到商为0为止。所得余数从下至上读取即为转换结果。下图演示了 $ 83D=1010011B $：

![Decimal to Binary](3DecBin.jpg)

十进制到二进制的换算，小数部分可采用**乘二取整法**：用小数部分不断乘以2，并记下积的整数部分，直到积的小数部分为0，或精度达到要求为止。所得整数从上至下即为转换结果。下图演示了 $ 0.8125D=0.1101B $：

![Decimal to Binary with Fraction](3DecBinFrac.jpg)

而二进制换算回十进制就比较简单了，直接按位权累加即可。

![Binary to Decimal with Cheat Sheet](3BinDec.jpg)

如你所见，**大部分十进制小数是不能被二进制小数精确地表示的**，只有完全契合二进制位权模式的数才能被精确表示。

### 数值数据

#### 无符号整数

没有正负号的**无符号整数（unsigned integer）** 直接用二进制就能表示了。

$ n $ 位无符号整数的表示范围是 $ [0, 2^n) $。

#### 有符号整数

有正负号的**有符号整数（signed integer）** 的表示就稍微复杂一点了。

假设有符号整数使用8位存储，最朴素的实现方法就是将该字节的最高位（最左侧位）变成**符号位**，`0` 表示正号、`1` 表示负号。这种表示方法称为**原码（sign magnitude）**，举例：

`3D=00000011B`，`-3D=10000011B`

但是，这样的存储方式，会导致异号数值相加（同号数值相减）变得繁琐。如何设计一种表示方法，能够通过二进制码的直接相加，来实现异号数值相加（同号数值相减）？

考虑一个只有时针的钟表，它能够存储的无符号整数的范围是 $ [0, 12) $。假如我要把时针往回拨7小时（$ -7 $），就等价于往前拨5小时（$ +5 $），这是因为 $ 12 - 7 = 5 $，此时的 $ 5 $ 就称为 $ -7 $ 对于 $ 12 $ 的补数。

![A Clock's Complement](3Clock.jpg)

同样的，要想二进制码也实现“以加代减”，我们只需要找到负数的**补码（complement）** 即可。考虑一个8位有符号二进制数，它能够存储的无符号整数的范围是 $ [00000000B, 01111111B) $。类比钟表，易证，负数 $ -n $ 的补码的表达式是 $ 01111111B - n $。可以证明，**负数 $ -n $ 的补码是将 $ |-n| $ 的原码按位取反后再 $ +1 $，而正数的补码就是其原码。**

> 下面检验用补码表示的 $ 3+(-3) $ 的结果是否正确：
>
> 因为 $ 3D=00000011B $ 且 $ -3D=10000000B+(\sim0000011B)+1B=11111101B \\ $
> 所以 $ 3D+(-3D)=00000011B+11111101B=100000000B $
>
> 我们发现，结果的后8位变成了全0，此时舍去第1位，便有 `00000000B=0D`。

由于符号位的存在，$ n $ 位有符号整数的表示范围是 $ [-2^{n-1}, 2^{n-1}) $。通常，当我们提及**整数（integer）** 一词的时候，我们默认指的是有符号整数。

#### 浮点数

如果我们想要表示小数呢？早期的计算机采用的是“定点数”的方法，所谓“定点”就是“小数点的位置是固定的”。比如我们可以约定，在8位中，前4位表示小数点前的数，后4位表示小数点后的数。但是这样的表示方法很显然效率比较低下，于是就出现了“浮点数”。

所谓“浮点”，就是我的小数点是可以“移动”的，不是固定在某个位上的。32位的早期浮点数是这样规定的：

![Classic Float](3Float.jpg)

**早期浮点数表示法：**

- **标准化：** 对于任意二进制小数，将其标准化为 $ \pm 0.N \times 2^K $ 后，设 $ N $ 为尾数，$ K $ 为指数。
- **前8位：指数（exponent）**，是有符号的补码，范围是 $ [-128, 128) $。
- **后24位：尾数（fraction）**，是有符号的原码。

> 尾数部分不采用补码的原因是，补码对增加浮点运算的速度没有太大帮助。

需要注意的是，目前（21世纪早期）采用的浮点数大多是 _**IEEE 754**_ 规范，与上面所述的早期表示方法**略有区别**。32位的 *IEEE 754* 浮点数是这样规定的：

![IEEE 754 Float](3FloatIEEE.jpg)

__*IEEE 754* 表示法：__

- **标准化：** 对于任意二进制小数，将其标准化为 $ \pm 1.N \times 2^K $ 后，设 $ N $ 为尾数，$ K $ 为指数。
- **第1位：符号位**，控制整个数的符号。
- **接着8位：指数**，但不同之处是，这里的指数是无符号的**移码**，不能直接使用，范围是 $ [0, 256) $。要想把它转化到 $ [-128, 128) $ 范围，直接 $ -128 $ 就行了。
- **后23位：尾数**，是无符号的原码。

> *IEEE 754* 约定标准化后的整数部分都是1，一定程度上扩展了能表示的有效位数。

32位的浮点数被称为**单精度浮点数（single float）**，有1符号位+8指数位+23尾数位；64位的浮点数被称为**双精度浮点数（double float）**，有1符号位+11指数位+52尾数位。

我们来简单讨论一下浮点数的精度。单精度浮点数有23位二进制尾数，由于 $ lg2^{23} \approx 6.92 $，因此单精度浮点数可以表示**6到7位有效数字**。双精度浮点数有52位二进制尾数，由于 $ lg2^{52} \approx 15.65 $，因此双精度浮点数可以表示**15到16位有效数字**。

### 文本数据

#### 西文字符

为了存储文本数据，在计算机中，要为每个字符指定一个二进制代码（字符编码），作为识别与使用这些字符的依据。最基础的编码规则是**美国标准信息交换码（American Standard Code for Information Interchange, [ASCII](https://en.wikipedia.org/wiki/ASCII)）**。

**ASCII 编码规则：**

- 用**1个字节**表示1个字符的编码。
- 第1位固定是0。
- 后7位用于编码：控制字符、阿拉伯数字、大小写英文字母和部分标点符号。

![ASCII Table](3ASCII.jpg)

其中，需要记住的重要ASCII字符有：

| |NUL|LF|CR|SPACE|0|A|a|
|---|---|---|---|---|---|---|---|
|Bin|`00000000`|`00001010`|`00001101`|`00000010`|`00110000`|`01000001`|`01100001`|
|Dec|`0`|`10`|`13`|`32`|`48`|`65`|`97`|
|Hex|`00`|`0A`|`0D`|`20`|`30`|`41`|`61`|

> **提示：**
>
> 上表的“Hex”指的是**十六进制（Hexadecimal）**。十六进制采用 `A,B,C,D,E,F` 来分别表示 `10,11,12,13,14,15`。每4个二进制数可以转化为1个十六进制数。
>
> 另外，不难发现，ASCII小写字母的编码是大写字母基础上的 $ +32D $ 或 $ +20H $。

那我其他欧美文字怎么办？正好ASCII的第1位是固定为0的，没有充分利用起来。我们把它变成1后，就又可以存储128个字符了。这样产生的编码规则被称为 **[ISO 8859](https://en.wikipedia.org/wiki/ISO/IEC_8859)** ，即扩展ASCII字符集，主要用于拉丁语系。
